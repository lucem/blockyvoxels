<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Chunk storage and compression (ideas - request for comment) - Blocky voxels and other fun things</title><meta name="description" content="How to compress Chunk Data? Chunks in raw form look a bit like this template &lt;typename TMaterialIndex&gt; struct Chunk { TMaterialIndex[][][] values; } // and&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://lucem.github.io/blockyvoxels/chunk-storage-and-compression-ideas-request-for-comment.html"><link rel="alternate" type="application/atom+xml" href="https://lucem.github.io/blockyvoxels/feed.xml"><link rel="alternate" type="application/json" href="https://lucem.github.io/blockyvoxels/feed.json"><meta property="og:title" content="Chunk storage and compression (ideas - request for comment)"><meta property="og:site_name" content="Blocky voxels and other fun things"><meta property="og:description" content="How to compress Chunk Data? Chunks in raw form look a bit like this template &lt;typename TMaterialIndex&gt; struct Chunk { TMaterialIndex[][][] values; } // and&hellip;"><meta property="og:url" content="https://lucem.github.io/blockyvoxels/chunk-storage-and-compression-ideas-request-for-comment.html"><meta property="og:type" content="article"><link rel="preload" href="https://lucem.github.io/blockyvoxels/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://lucem.github.io/blockyvoxels/assets/css/style.css?v=9c0f93417398e01e3c99419944d45d0d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://lucem.github.io/blockyvoxels/chunk-storage-and-compression-ideas-request-for-comment.html"},"headline":"Chunk storage and compression (ideas - request for comment)","datePublished":"2023-12-31T12:59","dateModified":"2023-12-31T13:01","description":"How to compress Chunk Data? Chunks in raw form look a bit like this template &lt;typename TMaterialIndex&gt; struct Chunk { TMaterialIndex[][][] values; } // and&hellip;","author":{"@type":"Person","name":"lucem","url":"https://lucem.github.io/blockyvoxels/authors/lucem/"},"publisher":{"@type":"Organization","name":"lucem"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="container"><header class="header"><div class="header__logo"><a class="logo" href="https://lucem.github.io/blockyvoxels/">Blocky voxels and other fun things</a></div></header><main class="content"><article class="post"><header><h1 class="post__title">Chunk storage and compression (ideas - request for comment)</h1><div class="post__meta"><time datetime="2023-12-31T12:59" class="post__date">December 31, 2023 </time><span class="post__author"><a href="https://lucem.github.io/blockyvoxels/authors/lucem/" class="feed__author">lucem</a></span></div></header><div class="post__entry"><h2>How to compress Chunk Data?</h2><p>Chunks in raw form look a bit like this</p><pre class="language-cpp"><code>template
&lt;typename TMaterialIndex&gt;
struct Chunk
{
  TMaterialIndex[][][] values;
}

// and convenient accessor functions </code></pre><p>or, more appropriately, like this</p><pre class="language-cpp"><code>template
&lt;typename TMaterialIndex&gt;
struct Chunk
{
  // flattened array of Dim X * Y * Z
  TMaterialIndex[] values;
}

// and convenient accessor functions </code></pre><p>or, fancy, with a union</p><pre class="language-cpp"><code>template
&lt;typename TMaterialIndex&gt;
struct Chunk
{
  union 
  {
    // 3D array representation with Dim [X][Y][Z]
    TMaterialIndex[][][] values3D;
    // flat array representation with Dim [X * Y * Z]
    TMaterialIndex[] valuesFlat;
  }
}

// and convenient accessor functions </code></pre><p>which is pretty good for runtime acces to data in memory, but quite large for storage.</p><h2>Compression methods</h2><p>Two immediate ideas come to my mind when thinking about compressing that data.</p><h3>Common stuff for both methods</h3><p>In every case, it is helpful to decompose this by material.</p><pre class="language-cpp"><code>struct BinaryChunk
{
union
{
  bool[][][] values3D;
  bool[] valuesFlat;
}

template
&lt;typename TMaterialIndex&gt;
int getIntFor(TMaterialIndex indexValue)
{
  // some means of converting whatever TMaterialIndex is to a unique Integer ID
  // can be just a cast in reality, this is just to illustrate and hint at the concept
}

struct Dictionary
{
  // for each int -&gt; TMaterialIndex, we get one BinaryChunk
  BinaryChunk[];
}</code></pre><p>So, we get a representation for each Material that tells us whether a given voxel is of that Material or not.</p><h3>Run-Length Encoding</h3><p>For RLE, we can just further condense these booleans into a simple array of bitmasks,<br>and use simple run length encoding to produce a compressed versions.</p><h3>Sparse Voxel Octrees</h3><p>For SVOs, we create an Octree where the leaf nodes hold a Boolean values telling us whether the enclosed volume is of a given Material or not.</p><p>We can then serialize that Octree to get a sparse representation.</p><h2>Doing both and selecting by compressed size</h2><p>This approach has the advantage of using the best compression result for any given input, at the expense of using more memory (and wasting some) and running both compression algorithms. We simply use both compression methods, look at the size of the produced data, and store one extra piece of information for each Material about the representation of the serialized data.</p><p>This way, we can ensure that we optimize for size, but at the expense of possibly significant runtime overhead.</p><h2>Other alternatives? Let me know</h2><p>If there are other approaches to this, let me know, I'm open for ideas.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on December 31, 2023</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://lucem.github.io/blockyvoxels/data-transformation-rendering.html" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  Data transformation - Rendering "><span class="btn__icon">‚Üê</span> <span class="btn__text">Data transformation - Rendering</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>Published initially on December 30th, 2023<br>Copyleft - lucem<br>Powered by Publii CMS</p></div></div></footer></div><script defer="defer" src="https://lucem.github.io/blockyvoxels/assets/js/scripts.min.js?v=74fad06980c30243d91d72c7c57fcdb8"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>