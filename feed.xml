<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Blocky voxels and other fun things</title>
    <link href="https://lucem.github.io/blockyvoxels/feed.xml" rel="self" />
    <link href="https://lucem.github.io/blockyvoxels" />
    <updated>2023-12-30T12:13:04+01:00</updated>
    <author>
        <name>lucem</name>
    </author>
    <id>https://lucem.github.io/blockyvoxels</id>

    <entry>
        <title>Space partitioning overview</title>
        <author>
            <name>lucem</name>
        </author>
        <link href="https://lucem.github.io/blockyvoxels/space-partitioning-overview.html"/>
        <id>https://lucem.github.io/blockyvoxels/space-partitioning-overview.html</id>

        <updated>2023-12-30T12:13:04+01:00</updated>
            <summary>
                <![CDATA[
                    (WIP - post is under construction and will be amended over time) One of the central ideas on how my voxel engine should work is&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>(WIP - post is under construction and will be amended over time)<br>One of the central ideas on how my voxel engine should work is the way space is partitioned and how voxel data is stored and accessed.</p>
<h2>Chunks</h2>
<p>Certainly, like in every other engine out there, voxels are grouped into Chunks of fixed size [Dx, Dy, Dz]. Typically, the 2D plane in which one moves is the [X,Z] plane, with Y representing the vertical direction "skywards". So, those are some of the basic assumptions about coordinate systems and their interpretation.</p>
<p>Such a Chunk is essentially a spatial datastructure storing information about the voxels contained in them, with implicit positioning, e.g. voxels do not store their own position vector.</p>
<p>!! This assumption at least is true for terrain !!</p>
<p>Above the Chunk layer, we have another spatial datastructure that allows us to relate Chunks relative to each other in 3D space. This might be flat, or hierarchical, in every cases, we can query that datastructure for which Chunk is associated with a certain point in Space, retrieve the Chunk data, get a distance metric to a Chunk etc.</p>
<p>At some point, this "higher level" spatial datastructure helps us decide when to load or unload a Chunk to and from memory.</p>
<p>Conceptually, a Chunk representing voxels is a Point Cloud - since the shape of voxels and a lot of other information is not necessary to store explicitly in a Chunk, all voxels essentially are just points in Space on a regular grid.</p>
<h2>View Models</h2>
<p>This notion of a regular 3D grid is, regardless of the underlying implementation, a useful view model to preserve for accessing Point (voxel) data, so this is one derived requirement we will have to observe - provide a 3D grid access model to voxel data.</p>
<p>Apart from that, we will want to have other view models on the same data. For ray marching, we might want to have a notion of an OcTree, so we can traverse fast and discard a lot of unnecessary checks. An interesting design question is, at which level of granularity do we need to offer which view model on the data. This is one of the open questions I am trying to answer when coming up with my preliminary system design.</p>
<h2>A hierarchy of (different) spatial indexing models</h2>
<p>When we look closely at how large World data can be, we early on must admit that we cannot possibly hold all of it in memory at the same time, and so we cannot use a uniform data abstraction at every level.</p>
<p>At some point also there will need to be a divergence of parallel models tailored to specific uses, that in combination form the representation of the World as a whole. There could be one data model that deals with geometry and efficiently storing and accessing that, while a completely different model might deal with collision detection and resolution; yet another might represent means of navigation, etc.</p>
<p>So, let's talk about geometry first, as that is what we already started upon.<br>We cannot hold all the geometry data in memory all the time for the whole World, so we need to devise a way to store this data to disk and have a way to interact with that storage - typically, find, retrieve, create and change data, in other words, the classical database operations of CRUD (create, retrieve, update, delete). If we think about Chunks, those are pretty easy to serialize and deserialize, and tend to take up a limited amount of storage space with a clear upper boundary - which makes it ideal to store as payload data in a database rather than complicated file formats. (But more on that later...)</p>
<p>For now, let us assume a simplified model of our data and how it may be spatially indexed in a hierarchical system. The actual model I am going for is a bit more complex than this, but not by a lot, and so this can serve as a good entry level overview on how this might be organised.</p>
<p>So, we already talked about Chunks and individual voxels. Let's call them Blocks for now, we are aiming at a blocky voxel engine after all ;)</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 99.886%;">Chunk</td>
</tr>
<tr>
<td style="width: 99.886%;">Block</td>
</tr>
</tbody>
</table>
<p>Obviously, we need more than one Chunk to build a reasonably large World, so we need a layer above that.</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 99.886%;">MapTile</td>
</tr>
<tr>
<td style="width: 99.886%;">Chunk</td>
</tr>
</tbody>
</table>
<p>We'll call this MapTile for now. Now, obviously, we're at a crossroads here - do we want an infinite map, or a finite one that has size limits and maybe another way of combining those finite sized maps into something yet again larger.</p>
<p>Since my goal is not to create a Minecraft clone, I can do away with infinite worlds in that sense, and am perfectly happy with finite maps.</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 99.886%;">Map</td>
</tr>
<tr>
<td style="width: 99.886%;">MapTile</td>
</tr>
</tbody>
</table>
<p>So, let's review this partitioning scheme, and may put some rough size examples to it to give us a sense of scale. Sizes in this case are in terms of the net smaller unit.</p>
<table style="border-collapse: collapse; width: 100%;" border="1">
<tbody>
<tr>
<td style="width: 16.6472%;"> </td>
<td style="width: 16.6472%;">Size X</td>
<td style="width: 16.6472%;">Size Z</td>
<td style="width: 16.6472%;">Size Y</td>
<td style="width: 16.6472%;">Area X-Z</td>
<td style="width: 16.6506%;">Volume XYZ</td>
</tr>
<tr>
<td style="width: 16.6472%;">Map</td>
<td style="width: 16.6472%;">16</td>
<td style="width: 16.6472%;">16</td>
<td style="width: 16.6472%;">16</td>
<td style="width: 16.6472%;">256</td>
<td style="width: 16.6506%;">4096</td>
</tr>
<tr>
<td style="width: 16.6472%;">MapTile</td>
<td style="width: 16.6472%;">16</td>
<td style="width: 16.6472%;">16</td>
<td style="width: 16.6472%;">16</td>
<td style="width: 16.6472%;">256</td>
<td style="width: 16.6506%;">4096</td>
</tr>
<tr>
<td style="width: 16.6472%;">Chunk</td>
<td style="width: 16.6472%;">256</td>
<td style="width: 16.6472%;">256</td>
<td style="width: 16.6472%;">64</td>
<td style="width: 16.6472%;">65536</td>
<td style="width: 16.6506%;">67 Mio.</td>
</tr>
<tr>
<td style="width: 16.6472%;">Block</td>
<td style="width: 16.6472%;">1</td>
<td style="width: 16.6472%;">1</td>
<td style="width: 16.6472%;">1</td>
<td style="width: 16.6472%;">1</td>
<td style="width: 16.6506%;">1</td>
</tr>
</tbody>
</table>
<p>Now, if we assume for simplicity's sake that a Block is a [1m,1m,1m] Cube than we already arrive at a significantly sized Map in terms of several square kilometres.<br>That is certainly something we can squeeze some serious amount of gameplay into, right? And all of that in just four levels of hierarchy (conceptually, anyway).</p>
<p>If we then proceed to have the World as a whole consist of several of these Maps, we easily arrive at a total World size rivaling or exceeding that of Planet Earth.<br>That is a lot of potential, but it also poses the difficult question of content creation for such a large environment.</p>
<p>As such, these are of course only ballpark figures to estimate resulting orders of magnitude in Map and World size. In practice, these things need to be fine tuned, and maybe even allow for variations (some Maps small, some medium sized, some large - something like that). Allowing these sorts of variations however is a consideration that needs to be considered when designing the systems that ultimately bring about implementation so all of this can be handled efficiently.</p>
<p>Something else to consider is that all of this data needs to be stored somewhere. Do we really want to create Exabytes of data and require a potential game to bring about this much data? Maybe scaling things down to drastically reduce storage requirements is a necessity, as well as efficiently compressing the data for storage.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>If anyone cares - how this blog works</title>
        <author>
            <name>lucem</name>
        </author>
        <link href="https://lucem.github.io/blockyvoxels/if-anyone-cares-how-this-blog-works.html"/>
        <id>https://lucem.github.io/blockyvoxels/if-anyone-cares-how-this-blog-works.html</id>

        <updated>2023-12-30T10:51:57+01:00</updated>
            <summary>
                <![CDATA[
                    Just for reference if anyone is curious, this blog is generated by a rather simple toolchain. I use Publii (https://getpublii.com) to write the content and&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Just for reference if anyone is curious, this blog is generated by a rather simple toolchain.</p>
<p>I use <a href="https://getpublii.com" title="Publii web site" target="_blank" rel="noopener noreferrer">Publii</a> (https://getpublii.com) to write the content and manage the overall site properties, which is a neat little static website generator.</p>
<p>I export the static website to a folder on my harddrive and then use a simple CLI script to copy the contents over to another folder that mirrors my 'pages' branch of my github repository, which is the source for <a href="https://lucem.github.io/blockyvoxels" title="front page - github pages - blocky voxels and other fun things" target="_blank" rel="noopener noreferrer">github pages</a>.</p>
<p>I then use github desktop to push the changes into that branch, because I'm lazy and it actually works quickly. Then it is a waiting game for a bunch of minutes and the updated blog is published. Done.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>So, blocky voxels...</title>
        <author>
            <name>lucem</name>
        </author>
        <link href="https://lucem.github.io/blockyvoxels/so-blocky-voxels.html"/>
        <id>https://lucem.github.io/blockyvoxels/so-blocky-voxels.html</id>

        <updated>2023-12-30T10:27:04+01:00</updated>
            <summary>
                <![CDATA[
                    Yet another blocky voxels engine. That should normally be the first thought that will naturally come to your mind. You think this kind of thing&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Yet another blocky voxels engine.</p>
<p>That should normally be the first thought that will naturally come to your mind.<br>You think this kind of thing has been done to death? Yeah, kind of. Still, I don't care much. I've seen a lot of those effort, too, and most of them are either bad Minecraft clones, or essentially just tech demos where you fly around and are bored within a minute.</p>
<p>I want to explore voxel based technology in a different context. So, to say this outright, my goal is not to clone Minecraft. It is however my goal to actually provide a playable game using this technology.</p>
<p>But first things first. Before there can be any game, there needs to be a solid grasp of the limitations of the technology first.</p>
<p>So here are my foundations:</p>
<p>C++ (maybe combined with an embedded scripting language later)<br>Moderate graphics hardware requirements<br>mesh-based rendering (no ray tracing that moderate graphics cards just can't do)<br>Less OOP than you might be comfortable with</p>
<p>On top of that, here are some other things I already decided upon:</p>
<p>Everything is made from voxels (yes, models too)<br>Database storage with spatial indexing for "model" data ("model" means everything that is made from voxels)<br>No texture switching (meaning the use of virtual texturing - textures possibly stored in the database as well)<br>Rendered geometry is ultimately generated on the GPU<br>Emphasis on tooling early on</p>
<p>What I have not decided upon just yet:</p>
<p>Roll my own rendering code or utilize existing rendering engines<br>other support libraries to go with that</p>
<p>For now, at this point in time, I am dealing with question of algorithmic and data structure design rather than implementation.</p>
<p> </p>
            ]]>
        </content>
    </entry>
</feed>
