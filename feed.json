{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blocky voxels and other fun things",
    "description": "",
    "home_page_url": "https://lucem.github.io/blockyvoxels",
    "feed_url": "https://lucem.github.io/blockyvoxels/feed.json",
    "user_comment": "",
    "author": {
        "name": "lucem"
    },
    "items": [
        {
            "id": "https://lucem.github.io/blockyvoxels/space-partitioning-for-real.html",
            "url": "https://lucem.github.io/blockyvoxels/space-partitioning-for-real.html",
            "title": "Space partitioning (for real)",
            "summary": "In the last post about space partitioning, I kind of laid out the ground work for the objectives and strategies, with some ballpark placeholder figures&hellip;",
            "content_html": "<p>In the last post about space partitioning, I kind of laid out the ground work for the objectives and strategies, with some ballpark placeholder figures to estimate the expected sizes involved.</p>\n<p>Now it's time to take a closer look on how this might actually pan out.</p>\n<p>First, let's look at the different hierarchy levels of partitioning and where they live in the system:</p>\n<figure class=\"post__image\"><img loading=\"lazy\"  src=\"https://lucem.github.io/blockyvoxels/media/posts/7/2023-12-31-table-space-partitioning-levels.png\" alt=\"Table: Space partitioning levels\" width=\"1051\" height=\"420\" sizes=\"(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)\" srcset=\"https://lucem.github.io/blockyvoxels/media/posts/7/responsive/2023-12-31-table-space-partitioning-levels-xs.png 300w ,https://lucem.github.io/blockyvoxels/media/posts/7/responsive/2023-12-31-table-space-partitioning-levels-sm.png 480w ,https://lucem.github.io/blockyvoxels/media/posts/7/responsive/2023-12-31-table-space-partitioning-levels-md.png 768w ,https://lucem.github.io/blockyvoxels/media/posts/7/responsive/2023-12-31-table-space-partitioning-levels-lg.png 1024w\"><figcaption>Table: Space partitioning levels</figcaption></figure>\n<p> </p>\n<p>It is important to note that in several parts of the engine different types and forms of subdivision are in use that all map to the same conceptual space; in this case, we are specifically adressing geometry storage for the rendering system.</p>\n<p>Each hierarchy level of subdivision has its own adressing scheme.</p>\n<h2>World</h2>\n<p>The World is the collection of everything that is contained in it.<br>As such, itself it really has no deeper relevance as a concept for the engine.</p>\n<h2>Sector</h2>\n<p>Sectors are the largest building blocks of the World.<br>In terms of what they represent in the game, they are akin to ring segments of the Dyson Ring structure (conceptually). Just like Regions, Sectors do not need to consider all spatial dimensions; in this case, Sectors are simply a one-dimensional structure.</p>\n<h2>Region</h2>\n<p>Regions make up Sectors and are larger subdivisions of Dyson Ring segments. At this scale, we no longer need to consider three spatial dimensions, and can simplify to a two-dimensional partitioning.</p>\n<h2>Map</h2>\n<p>A Map is the largest volume of space with a collision volume attached to it in memory.</p>\n<h2>MapTile</h2>\n<p>Since holding a whole Map in memory all the time is not quite resource efficient, there is an intermediate step called MapTile that is a smaller subdivision of a Map.</p>\n<h2>Chunk</h2>\n<p>A Chunk is the partition level where geometry data is actually stored. A number of Chunks make up a MapTile. Chunks consists of a regular subdivision into individual Blocks.</p>\n<h2>Block</h2>\n<p>Blocks are individual voxels. They exist in three levels of detail, but conceptually are not independent. Block positions are implicit.</p>\n<h3>Block - coarse LOD</h3>\n<h3>Block - medium LOD</h3>\n<h3>Block - fine LOD</h3>\n<p>The levels of detail are just further regular subdivisions of Blocks to help the engine draw more detail in the immediate (camera) neighborhood.</p>\n<p>!! If the same effect can be convincingly generated by means of parallax mapping to increase the level of apparent surface detail at close range, the LOD approach can be gratly simplified; because of this, the LOD outlined here is to be understood as a placeholder until actual experiments have been carried out. !!</p>\n<p> </p>\n<p> </p>",
            "author": {
                "name": "lucem"
            },
            "tags": [
            ],
            "date_published": "2023-12-31T07:12:21+01:00",
            "date_modified": "2023-12-31T10:29:32+01:00"
        },
        {
            "id": "https://lucem.github.io/blockyvoxels/what-the-game-might-be.html",
            "url": "https://lucem.github.io/blockyvoxels/what-the-game-might-be.html",
            "title": "What the Game might be",
            "summary": "(WIP - will be amended over time) In order to not just talk about voxel stuff in a vaccuum, I think I need to outline&hellip;",
            "content_html": "<p>(WIP - will be amended over time)<br>In order to not just talk about voxel stuff in a vaccuum, I think I need to outline what the game idea is that this technology is used (and built) for.</p>\n<h2>A twin-stick 3rd person shooter in a voxel world</h2>\n<p>So, the essential cornerstone idea is to have a twin-stick 3rd person shooter taking place in a voxel environment. This involves partially destructible terrain, a number of moving characters on screen, weapons handling (ranged weapons only for now I think) and all the good things that go with it.<br>This is of course completely different than your essential Minecraft clone.</p>\n<h2>Arcade type look and feel</h2>\n<p>Realism, stay away. This game is supposed to look unrealistic. Think of stuff like stylized visuals, bright colors, and visual effects like CRT emulation with the corresponding glitches, chromatic aberrations and distortions. Also, in the same vein, for a complete retro look and feel, some form of lower resolution rendering and upscaling would feel just right.</p>\n<p>Of course, the possible level of post-processing effects like these depends on the rendering performance as a whole, so what can be achieved depends entirely on the basic raw rendering performance achievable.</p>\n<h2>Scenario background and inspiration</h2>\n<p>The scenario the game is based upon is a lot older than the decision to make it a twin stick shooter. In fact, much older, and the idea of making this with voxels and (at least partially) destructive terrain first led to the question: what kind of game can I make in this type of environment that makes sense for the scenario and is doable for a single developer? A lot of the decisions were made with these two questions as a starting point. For example, I cannot model in traditional 3D modelling software to save my life, so I need something I can actually get some reasonable results with - and thus, modelling in voxels (after some inspiration from seeing tools like MagickaVoxel arise just around the time I was trying to come up with this stuff, of course) became the go to solution. But then, I need to animate those. The obvious answer on how to do that is skeletal animation. How do I avoid having to spend hours upon hours on modelling the same type of stuff over and over again? Well, modular models built from components that are interchangeable and give you combinatorial diversity. And so the list goes on.</p>\n<p>So, what is this mystical scenario this all was based upon? Nothing incredibly new or fancy, just reading too much Larry Niven (and, to my dismay I must confess, I have not played a single minute of Halo, so this is only peripherally influential) - Ringworld. In particular, the question on how a Dyson Ring would work as a game environment. How would such a Ring need to be constructed? How large would it be? Would a full Dyson Ring be possible (it's not, that is way too large) or a smaller version in orbit around a planet or maybe a ring around a planet (scientifically very difficult, as that would be highly unstable). So, in essence, in the beginning there was a lot of science fiction, and in that, much more science than one might think.</p>\n<p>In the end, I arrived at the following conclusions:<br>- a solid ring is infeasible and unrealistic<br>- the most feasible ring possible is in orbit of a planetary body (or in one of the Lagrange Points)<br>- such a structure would by necessity be segmented and have very high walls<br>- still, any one of those segments would be pretty damn large<br>- in effect, the walkable surface of such a ring is enormously large, as dictated by the minimum size constraints</p>\n<p>But this gives us a few constraints to work with when talking about Maps for the game:<br>- Maps are typically quite large<br>- Each Map is a part of a ring segment or a complete ring segment, so it is confined by very high walls<br>- Maps are limited in depth and there needs to be some layer of impenetrable unobtanium as a material strong enough to make a stable ring structure<br>- There must be some kind of transportation system infrastructure built into the ring itself, traversing distances inside segments and between segments<br>- In such a scifi scenario, we can take some leeway with realism and allow things like transporters, ray guns, and other fun things, as long as we don't break any obvious rules of nature - but it for sure need not be ultra-hard scifi</p>\n<p>So, this is the initial idea. A Ringworld, a segmented Dyson Ring of roughly the surface dimensions of a Planet, and as such, coming with all the nice tropes we know from scifi stuff. Now all we need is a game.</p>\n<h2>Story</h2>\n<p>In the old days, games did not need story at all. Or, very rudimentary ones at best.<br>I'm doing my best to provide some sort of world building without pressing the whole thing into a restricting corset.</p>\n<h3>Starting out</h3>\n<p>You find yourself stranded on the Ring structure after a catastrophic failure of several systems of your small ship. Your mission was forward recon for the following starship on its way to establish a new colony on one of the planets in this solar system. They are however still far out, and you are left with no functioning propulsion system, nor communications. The existence of the Ring also was previously not known and came as a bit of a surprise. Even worse is the fact that you don't seem to be alone here after all.</p>\n<h3>Goal</h3>\n<p>Your overall goal is to find some means of communication with your home starship, both to disclose your position for rescue and to advise them of what you found out here. As you explore your surroundings, you hope you can decipher and analyze what you find and eventually learn to use the Ring infrastructure to establish communication.</p>",
            "author": {
                "name": "lucem"
            },
            "tags": [
            ],
            "date_published": "2023-12-30T12:32:01+01:00",
            "date_modified": "2023-12-31T11:31:25+01:00"
        },
        {
            "id": "https://lucem.github.io/blockyvoxels/space-partitioning-overview.html",
            "url": "https://lucem.github.io/blockyvoxels/space-partitioning-overview.html",
            "title": "Space partitioning overview",
            "summary": "(WIP - post is under construction and will be amended over time) One of the central ideas on how my voxel engine should work is&hellip;",
            "content_html": "<p>(WIP - post is under construction and will be amended over time)<br>One of the central ideas on how my voxel engine should work is the way space is partitioned and how voxel data is stored and accessed.</p>\n<h2>Chunks</h2>\n<p>Certainly, like in every other engine out there, voxels are grouped into Chunks of fixed size [Dx, Dy, Dz]. <span style=\"text-decoration: line-through;\">Typically, the 2D plane in which one moves is the [X,Z] plane, with Y representing the vertical direction \"skywards\". So, those are some of the basic assumptions about coordinate systems and their interpretation.</span></p>\n<p>Typically, the 2D plane in which one moves is the [X,Y] plane, with Z representing the vertical direction \"skywards\". (Left the old paragraph in, but Z up is actually more in congruence with other unrelated things I work with, so I'll try to keep things consistent so I don't have to think too hard all the time) So, those are some of the basic assumptions about coordinate systems and their interpretation.</p>\n<p>Such a Chunk is essentially a spatial datastructure storing information about the voxels contained in them, with implicit positioning, e.g. voxels do not store their own position vector.</p>\n<p>!! This assumption at least is true for terrain !!</p>\n<p>Above the Chunk layer, we have another spatial datastructure that allows us to relate Chunks relative to each other in 3D space. This might be flat, or hierarchical, in every cases, we can query that datastructure for which Chunk is associated with a certain point in Space, retrieve the Chunk data, get a distance metric to a Chunk etc.</p>\n<p>At some point, this \"higher level\" spatial datastructure helps us decide when to load or unload a Chunk to and from memory.</p>\n<p>Conceptually, a Chunk representing voxels is a Point Cloud - since the shape of voxels and a lot of other information is not necessary to store explicitly in a Chunk, all voxels essentially are just points in Space on a regular grid.</p>\n<h2>View Models</h2>\n<p>This notion of a regular 3D grid is, regardless of the underlying implementation, a useful view model to preserve for accessing Point (voxel) data, so this is one derived requirement we will have to observe - provide a 3D grid access model to voxel data.</p>\n<p>Apart from that, we will want to have other view models on the same data. For ray marching, we might want to have a notion of an OcTree, so we can traverse fast and discard a lot of unnecessary checks. An interesting design question is, at which level of granularity do we need to offer which view model on the data. This is one of the open questions I am trying to answer when coming up with my preliminary system design.</p>\n<h2>A hierarchy of (different) spatial indexing models</h2>\n<p>When we look closely at how large World data can be, we early on must admit that we cannot possibly hold all of it in memory at the same time, and so we cannot use a uniform data abstraction at every level.</p>\n<p>At some point also there will need to be a divergence of parallel models tailored to specific uses, that in combination form the representation of the World as a whole. There could be one data model that deals with geometry and efficiently storing and accessing that, while a completely different model might deal with collision detection and resolution; yet another might represent means of navigation, etc.</p>\n<p>So, let's talk about geometry first, as that is what we already started upon.<br>We cannot hold all the geometry data in memory all the time for the whole World, so we need to devise a way to store this data to disk and have a way to interact with that storage - typically, find, retrieve, create and change data, in other words, the classical database operations of CRUD (create, retrieve, update, delete). If we think about Chunks, those are pretty easy to serialize and deserialize, and tend to take up a limited amount of storage space with a clear upper boundary - which makes it ideal to store as payload data in a database rather than complicated file formats. (But more on that later...)</p>\n<p>For now, let us assume a simplified model of our data and how it may be spatially indexed in a hierarchical system. The actual model I am going for is a bit more complex than this, but not by a lot, and so this can serve as a good entry level overview on how this might be organised.</p>\n<p>So, we already talked about Chunks and individual voxels. Let's call them Blocks for now, we are aiming at a blocky voxel engine after all ;)</p>\n<table style=\"border-collapse: collapse; width: 100%;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 99.886%;\">Chunk</td>\n</tr>\n<tr>\n<td style=\"width: 99.886%;\">Block</td>\n</tr>\n</tbody>\n</table>\n<p>Obviously, we need more than one Chunk to build a reasonably large World, so we need a layer above that.</p>\n<table style=\"border-collapse: collapse; width: 100%;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 99.886%;\">MapTile</td>\n</tr>\n<tr>\n<td style=\"width: 99.886%;\">Chunk</td>\n</tr>\n</tbody>\n</table>\n<p>We'll call this MapTile for now. Now, obviously, we're at a crossroads here - do we want an infinite map, or a finite one that has size limits and maybe another way of combining those finite sized maps into something yet again larger.</p>\n<p>Since my goal is not to create a Minecraft clone, I can do away with infinite worlds in that sense, and am perfectly happy with finite maps.</p>\n<table style=\"border-collapse: collapse; width: 100%;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 99.886%;\">Map</td>\n</tr>\n<tr>\n<td style=\"width: 99.886%;\">MapTile</td>\n</tr>\n</tbody>\n</table>\n<p>So, let's review this partitioning scheme, and may put some rough size examples to it to give us a sense of scale. Sizes in this case are in terms of the net smaller unit.</p>\n<table style=\"border-collapse: collapse; width: 100%;\" border=\"1\">\n<tbody>\n<tr>\n<td style=\"width: 16.6472%;\"> </td>\n<td style=\"width: 16.6472%;\">Size X</td>\n<td style=\"width: 16.6472%;\">Size Z</td>\n<td style=\"width: 16.6472%;\">Size Y</td>\n<td style=\"width: 16.6472%;\">Area X-Z</td>\n<td style=\"width: 16.6506%;\">Volume XYZ</td>\n</tr>\n<tr>\n<td style=\"width: 16.6472%;\">Map</td>\n<td style=\"width: 16.6472%;\">16</td>\n<td style=\"width: 16.6472%;\">16</td>\n<td style=\"width: 16.6472%;\">16</td>\n<td style=\"width: 16.6472%;\">256</td>\n<td style=\"width: 16.6506%;\">4096</td>\n</tr>\n<tr>\n<td style=\"width: 16.6472%;\">MapTile</td>\n<td style=\"width: 16.6472%;\">16</td>\n<td style=\"width: 16.6472%;\">16</td>\n<td style=\"width: 16.6472%;\">16</td>\n<td style=\"width: 16.6472%;\">256</td>\n<td style=\"width: 16.6506%;\">4096</td>\n</tr>\n<tr>\n<td style=\"width: 16.6472%;\">Chunk</td>\n<td style=\"width: 16.6472%;\">256</td>\n<td style=\"width: 16.6472%;\">256</td>\n<td style=\"width: 16.6472%;\">64</td>\n<td style=\"width: 16.6472%;\">65536</td>\n<td style=\"width: 16.6506%;\">67 Mio.</td>\n</tr>\n<tr>\n<td style=\"width: 16.6472%;\">Block</td>\n<td style=\"width: 16.6472%;\">1</td>\n<td style=\"width: 16.6472%;\">1</td>\n<td style=\"width: 16.6472%;\">1</td>\n<td style=\"width: 16.6472%;\">1</td>\n<td style=\"width: 16.6506%;\">1</td>\n</tr>\n</tbody>\n</table>\n<p>Now, if we assume for simplicity's sake that a Block is a [1m,1m,1m] Cube than we already arrive at a significantly sized Map in terms of several square kilometres.<br>That is certainly something we can squeeze some serious amount of gameplay into, right? And all of that in just four levels of hierarchy (conceptually, anyway).</p>\n<p>If we then proceed to have the World as a whole consist of several of these Maps, we easily arrive at a total World size rivaling or exceeding that of Planet Earth.<br>That is a lot of potential, but it also poses the difficult question of content creation for such a large environment.</p>\n<p>As such, these are of course only ballpark figures to estimate resulting orders of magnitude in Map and World size. In practice, these things need to be fine tuned, and maybe even allow for variations (some Maps small, some medium sized, some large - something like that). Allowing these sorts of variations however is a consideration that needs to be considered when designing the systems that ultimately bring about implementation so all of this can be handled efficiently.</p>\n<p>Something else to consider is that all of this data needs to be stored somewhere. Do we really want to create Exabytes of data and require a potential game to bring about this much data? Maybe scaling things down to drastically reduce storage requirements is a necessity, as well as efficiently compressing the data for storage.</p>\n<h2>Terrain and Models and ...</h2>\n<p>So far, the ideas presented are structured around terrain and its features. That is all well and good, but in order to have a game, a (somewhat static) environment is not enough. You need to have dynamic elements, things that move and are independent of the surrounding environment - in most cases, these are done as models. We'll see that this might not be the best approach here.</p>\n<p>Typically, models are pre-fabricated meshes, with or without animation baked in, and the textures and other material data that go along with them.<br>Now, textures and materials are also necessary for making interesting terrain, so those are resources that can be shared. (And, since one of the technology goals is to avoid binding different textures, they actually need to be shared)</p>\n<p>Textures for models typically come in the form of UV maps, so texture coordinates (uv's) are baked into the mesh data and map to something that looks like a squashed version of the model's features that is laid flat in a 2D texture.<br>That is a workable approach if you can bind a texture per model, but not really if you want to avoid constant rebinding of textures. So, any model (i use the term very loosely here) that wants to work within this engine technology needs to work with the same texture layout and approach as the terrain. Thus, UV maps are basically out of the question.</p>\n<p>Another thing of notice is that having meshed models in a voxel environment does not really provide for a lot of coherence. So, the neatest approach in that regard is to build models out of voxels as well - however, these do not conform to the strict grid alignment and axis alignment as the uniform blocks the terrain is made of, so they still need to be treated differently. Also, having models almost universally requires having animations for them, which would be very hard to do within the confines of data structures built for terrain data storage.</p>\n<p>Thus, terrain and models need to be kept seperate and treated differently.</p>\n<h2>Combining seperate things</h2>\n<p>But then, we face the problem of having models interacting with the environment they are placed in. So, even though they are seperate, they are not, and this aspect needs to be reflected in the data structures somehow.</p>\n<p>I hinted at that before a bit, there need to exist specialized data structures, each of thise optimized for certain aspects, and then other ones where common concerns require representing them together in one structure.</p>\n<p>The most obvious concern of this is having collisions. These are the basis of things like simulating physics (whether arcade style or actual simulations of realistic physics does not matter).</p>\n<p>So, usually the temptation would be to have one spatial datastructure that envelops all those aspects of the world in a unified way. This gets messy very, very quickly. Having seperate, independent data structures as silos then again also opens up another hard problem, which is synchronisation.<br>As this is an overview document, I am not going to dive too deep into this problem set right now - for now, it is sufficient to point out that these issues exist and need to be dealt with.</p>",
            "author": {
                "name": "lucem"
            },
            "tags": [
            ],
            "date_published": "2023-12-30T11:43:22+01:00",
            "date_modified": "2023-12-30T15:16:13+01:00"
        },
        {
            "id": "https://lucem.github.io/blockyvoxels/if-anyone-cares-how-this-blog-works.html",
            "url": "https://lucem.github.io/blockyvoxels/if-anyone-cares-how-this-blog-works.html",
            "title": "If anyone cares - how this blog works",
            "summary": "Just for reference if anyone is curious, this blog is generated by a rather simple toolchain. I use Publii (https://getpublii.com) to write the content and&hellip;",
            "content_html": "<p>Just for reference if anyone is curious, this blog is generated by a rather simple toolchain.</p>\n<p>I use <a href=\"https://getpublii.com\" title=\"Publii web site\" target=\"_blank\" rel=\"noopener noreferrer\">Publii</a> (https://getpublii.com) to write the content and manage the overall site properties, which is a neat little static website generator.</p>\n<p>I export the static website to a folder on my harddrive and then use a simple CLI script to copy the contents over to another folder that mirrors my 'pages' branch of my github repository, which is the source for <a href=\"https://lucem.github.io/blockyvoxels\" title=\"front page - github pages - blocky voxels and other fun things\" target=\"_blank\" rel=\"noopener noreferrer\">github pages</a>.</p>\n<p>I then use github desktop to push the changes into that branch, because I'm lazy and it actually works quickly. Then it is a waiting game for a bunch of minutes and the updated blog is published. Done.</p>",
            "author": {
                "name": "lucem"
            },
            "tags": [
            ],
            "date_published": "2023-12-30T10:51:57+01:00",
            "date_modified": "2023-12-30T10:51:57+01:00"
        },
        {
            "id": "https://lucem.github.io/blockyvoxels/so-blocky-voxels.html",
            "url": "https://lucem.github.io/blockyvoxels/so-blocky-voxels.html",
            "title": "So, blocky voxels...",
            "summary": "Yet another blocky voxels engine. That should normally be the first thought that will naturally come to your mind. You think this kind of thing&hellip;",
            "content_html": "<p>Yet another blocky voxels engine.</p>\n<p>That should normally be the first thought that will naturally come to your mind.<br>You think this kind of thing has been done to death? Yeah, kind of. Still, I don't care much. I've seen a lot of those effort, too, and most of them are either bad Minecraft clones, or essentially just tech demos where you fly around and are bored within a minute.</p>\n<p>I want to explore voxel based technology in a different context. So, to say this outright, my goal is not to clone Minecraft. It is however my goal to actually provide a playable game using this technology.</p>\n<p>So, why blocky voxels specifically? I think it lends itself better to a certain visual style, which is in the arcade / highly stylized, almost comic-like tradition. You would not expect games like SmashTV or Cannon Fodder to look realistic - it would take away from their appeal. With the game I have in mind, smooth and realistic visuals are a bit out of place. I think blocky voxels, consistently used throught all of the in-game elements, lend themselves better to what I have in mind.</p>\n<p>But first things first. Before there can be any game, there needs to be a solid grasp of the limitations of the technology first.</p>\n<p>So here are my foundations:</p>\n<p>C++ (maybe combined with an embedded scripting language later)<br>Moderate graphics hardware requirements<br>mesh-based rendering (no ray tracing that moderate graphics cards just can't do)<br>Less OOP than you might be comfortable with</p>\n<p>On top of that, here are some other things I already decided upon:</p>\n<p>Everything is made from voxels (yes, models too)<br>Database storage with spatial indexing for \"model\" data (\"model\" means everything that is made from voxels)<br>No texture switching (meaning the use of virtual texturing - textures possibly stored in the database as well)<br>Rendered geometry is ultimately generated on the GPU<br>Emphasis on tooling early on</p>\n<p>What I have not decided upon just yet:</p>\n<p>Roll my own rendering code or utilize existing rendering engines<br>other support libraries to go with that</p>\n<p>For now, at this point in time, I am dealing with question of algorithmic and data structure design rather than implementation.</p>\n<p> </p>",
            "author": {
                "name": "lucem"
            },
            "tags": [
            ],
            "date_published": "2023-12-30T10:27:04+01:00",
            "date_modified": "2023-12-30T15:14:31+01:00"
        }
    ]
}
