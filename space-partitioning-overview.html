<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Space partitioning overview - Blocky voxels and other fun things</title><meta name="description" content="(WIP - post is under construction and will be amended over time) One of the central ideas on how my voxel engine should work is&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://lucem.github.io/blockyvoxels/space-partitioning-overview.html"><link rel="alternate" type="application/atom+xml" href="https://lucem.github.io/blockyvoxels/feed.xml"><link rel="alternate" type="application/json" href="https://lucem.github.io/blockyvoxels/feed.json"><meta property="og:title" content="Space partitioning overview"><meta property="og:site_name" content="Blocky voxels and other fun things"><meta property="og:description" content="(WIP - post is under construction and will be amended over time) One of the central ideas on how my voxel engine should work is&hellip;"><meta property="og:url" content="https://lucem.github.io/blockyvoxels/space-partitioning-overview.html"><meta property="og:type" content="article"><link rel="preload" href="https://lucem.github.io/blockyvoxels/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://lucem.github.io/blockyvoxels/assets/css/style.css?v=9c0f93417398e01e3c99419944d45d0d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://lucem.github.io/blockyvoxels/space-partitioning-overview.html"},"headline":"Space partitioning overview","datePublished":"2023-12-30T11:43","dateModified":"2023-12-30T15:16","description":"(WIP - post is under construction and will be amended over time) One of the central ideas on how my voxel engine should work is&hellip;","author":{"@type":"Person","name":"lucem","url":"https://lucem.github.io/blockyvoxels/authors/lucem/"},"publisher":{"@type":"Organization","name":"lucem"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="container"><header class="header"><div class="header__logo"><a class="logo" href="https://lucem.github.io/blockyvoxels/">Blocky voxels and other fun things</a></div></header><main class="content"><article class="post"><header><h1 class="post__title">Space partitioning overview</h1><div class="post__meta"><time datetime="2023-12-30T11:43" class="post__date">December 30, 2023 </time><span class="post__author"><a href="https://lucem.github.io/blockyvoxels/authors/lucem/" class="feed__author">lucem</a></span></div></header><div class="post__entry"><p>(WIP - post is under construction and will be amended over time)<br>One of the central ideas on how my voxel engine should work is the way space is partitioned and how voxel data is stored and accessed.</p><h2>Chunks</h2><p>Certainly, like in every other engine out there, voxels are grouped into Chunks of fixed size [Dx, Dy, Dz]. <span style="text-decoration: line-through;">Typically, the 2D plane in which one moves is the [X,Z] plane, with Y representing the vertical direction "skywards". So, those are some of the basic assumptions about coordinate systems and their interpretation.</span></p><p>Typically, the 2D plane in which one moves is the [X,Y] plane, with Z representing the vertical direction "skywards". (Left the old paragraph in, but Z up is actually more in congruence with other unrelated things I work with, so I'll try to keep things consistent so I don't have to think too hard all the time) So, those are some of the basic assumptions about coordinate systems and their interpretation.</p><p>Such a Chunk is essentially a spatial datastructure storing information about the voxels contained in them, with implicit positioning, e.g. voxels do not store their own position vector.</p><p>!! This assumption at least is true for terrain !!</p><p>Above the Chunk layer, we have another spatial datastructure that allows us to relate Chunks relative to each other in 3D space. This might be flat, or hierarchical, in every cases, we can query that datastructure for which Chunk is associated with a certain point in Space, retrieve the Chunk data, get a distance metric to a Chunk etc.</p><p>At some point, this "higher level" spatial datastructure helps us decide when to load or unload a Chunk to and from memory.</p><p>Conceptually, a Chunk representing voxels is a Point Cloud - since the shape of voxels and a lot of other information is not necessary to store explicitly in a Chunk, all voxels essentially are just points in Space on a regular grid.</p><h2>View Models</h2><p>This notion of a regular 3D grid is, regardless of the underlying implementation, a useful view model to preserve for accessing Point (voxel) data, so this is one derived requirement we will have to observe - provide a 3D grid access model to voxel data.</p><p>Apart from that, we will want to have other view models on the same data. For ray marching, we might want to have a notion of an OcTree, so we can traverse fast and discard a lot of unnecessary checks. An interesting design question is, at which level of granularity do we need to offer which view model on the data. This is one of the open questions I am trying to answer when coming up with my preliminary system design.</p><h2>A hierarchy of (different) spatial indexing models</h2><p>When we look closely at how large World data can be, we early on must admit that we cannot possibly hold all of it in memory at the same time, and so we cannot use a uniform data abstraction at every level.</p><p>At some point also there will need to be a divergence of parallel models tailored to specific uses, that in combination form the representation of the World as a whole. There could be one data model that deals with geometry and efficiently storing and accessing that, while a completely different model might deal with collision detection and resolution; yet another might represent means of navigation, etc.</p><p>So, let's talk about geometry first, as that is what we already started upon.<br>We cannot hold all the geometry data in memory all the time for the whole World, so we need to devise a way to store this data to disk and have a way to interact with that storage - typically, find, retrieve, create and change data, in other words, the classical database operations of CRUD (create, retrieve, update, delete). If we think about Chunks, those are pretty easy to serialize and deserialize, and tend to take up a limited amount of storage space with a clear upper boundary - which makes it ideal to store as payload data in a database rather than complicated file formats. (But more on that later...)</p><p>For now, let us assume a simplified model of our data and how it may be spatially indexed in a hierarchical system. The actual model I am going for is a bit more complex than this, but not by a lot, and so this can serve as a good entry level overview on how this might be organised.</p><p>So, we already talked about Chunks and individual voxels. Let's call them Blocks for now, we are aiming at a blocky voxel engine after all ;)</p><table style="border-collapse: collapse; width: 100%;" border="1"><tbody><tr><td style="width: 99.886%;">Chunk</td></tr><tr><td style="width: 99.886%;">Block</td></tr></tbody></table><p>Obviously, we need more than one Chunk to build a reasonably large World, so we need a layer above that.</p><table style="border-collapse: collapse; width: 100%;" border="1"><tbody><tr><td style="width: 99.886%;">MapTile</td></tr><tr><td style="width: 99.886%;">Chunk</td></tr></tbody></table><p>We'll call this MapTile for now. Now, obviously, we're at a crossroads here - do we want an infinite map, or a finite one that has size limits and maybe another way of combining those finite sized maps into something yet again larger.</p><p>Since my goal is not to create a Minecraft clone, I can do away with infinite worlds in that sense, and am perfectly happy with finite maps.</p><table style="border-collapse: collapse; width: 100%;" border="1"><tbody><tr><td style="width: 99.886%;">Map</td></tr><tr><td style="width: 99.886%;">MapTile</td></tr></tbody></table><p>So, let's review this partitioning scheme, and may put some rough size examples to it to give us a sense of scale. Sizes in this case are in terms of the net smaller unit.</p><table style="border-collapse: collapse; width: 100%;" border="1"><tbody><tr><td style="width: 16.6472%;"> </td><td style="width: 16.6472%;">Size X</td><td style="width: 16.6472%;">Size Z</td><td style="width: 16.6472%;">Size Y</td><td style="width: 16.6472%;">Area X-Z</td><td style="width: 16.6506%;">Volume XYZ</td></tr><tr><td style="width: 16.6472%;">Map</td><td style="width: 16.6472%;">16</td><td style="width: 16.6472%;">16</td><td style="width: 16.6472%;">16</td><td style="width: 16.6472%;">256</td><td style="width: 16.6506%;">4096</td></tr><tr><td style="width: 16.6472%;">MapTile</td><td style="width: 16.6472%;">16</td><td style="width: 16.6472%;">16</td><td style="width: 16.6472%;">16</td><td style="width: 16.6472%;">256</td><td style="width: 16.6506%;">4096</td></tr><tr><td style="width: 16.6472%;">Chunk</td><td style="width: 16.6472%;">256</td><td style="width: 16.6472%;">256</td><td style="width: 16.6472%;">64</td><td style="width: 16.6472%;">65536</td><td style="width: 16.6506%;">67 Mio.</td></tr><tr><td style="width: 16.6472%;">Block</td><td style="width: 16.6472%;">1</td><td style="width: 16.6472%;">1</td><td style="width: 16.6472%;">1</td><td style="width: 16.6472%;">1</td><td style="width: 16.6506%;">1</td></tr></tbody></table><p>Now, if we assume for simplicity's sake that a Block is a [1m,1m,1m] Cube than we already arrive at a significantly sized Map in terms of several square kilometres.<br>That is certainly something we can squeeze some serious amount of gameplay into, right? And all of that in just four levels of hierarchy (conceptually, anyway).</p><p>If we then proceed to have the World as a whole consist of several of these Maps, we easily arrive at a total World size rivaling or exceeding that of Planet Earth.<br>That is a lot of potential, but it also poses the difficult question of content creation for such a large environment.</p><p>As such, these are of course only ballpark figures to estimate resulting orders of magnitude in Map and World size. In practice, these things need to be fine tuned, and maybe even allow for variations (some Maps small, some medium sized, some large - something like that). Allowing these sorts of variations however is a consideration that needs to be considered when designing the systems that ultimately bring about implementation so all of this can be handled efficiently.</p><p>Something else to consider is that all of this data needs to be stored somewhere. Do we really want to create Exabytes of data and require a potential game to bring about this much data? Maybe scaling things down to drastically reduce storage requirements is a necessity, as well as efficiently compressing the data for storage.</p><h2>Terrain and Models and ...</h2><p>So far, the ideas presented are structured around terrain and its features. That is all well and good, but in order to have a game, a (somewhat static) environment is not enough. You need to have dynamic elements, things that move and are independent of the surrounding environment - in most cases, these are done as models. We'll see that this might not be the best approach here.</p><p>Typically, models are pre-fabricated meshes, with or without animation baked in, and the textures and other material data that go along with them.<br>Now, textures and materials are also necessary for making interesting terrain, so those are resources that can be shared. (And, since one of the technology goals is to avoid binding different textures, they actually need to be shared)</p><p>Textures for models typically come in the form of UV maps, so texture coordinates (uv's) are baked into the mesh data and map to something that looks like a squashed version of the model's features that is laid flat in a 2D texture.<br>That is a workable approach if you can bind a texture per model, but not really if you want to avoid constant rebinding of textures. So, any model (i use the term very loosely here) that wants to work within this engine technology needs to work with the same texture layout and approach as the terrain. Thus, UV maps are basically out of the question.</p><p>Another thing of notice is that having meshed models in a voxel environment does not really provide for a lot of coherence. So, the neatest approach in that regard is to build models out of voxels as well - however, these do not conform to the strict grid alignment and axis alignment as the uniform blocks the terrain is made of, so they still need to be treated differently. Also, having models almost universally requires having animations for them, which would be very hard to do within the confines of data structures built for terrain data storage.</p><p>Thus, terrain and models need to be kept seperate and treated differently.</p><h2>Combining seperate things</h2><p>But then, we face the problem of having models interacting with the environment they are placed in. So, even though they are seperate, they are not, and this aspect needs to be reflected in the data structures somehow.</p><p>I hinted at that before a bit, there need to exist specialized data structures, each of thise optimized for certain aspects, and then other ones where common concerns require representing them together in one structure.</p><p>The most obvious concern of this is having collisions. These are the basis of things like simulating physics (whether arcade style or actual simulations of realistic physics does not matter).</p><p>So, usually the temptation would be to have one spatial datastructure that envelops all those aspects of the world in a unified way. This gets messy very, very quickly. Having seperate, independent data structures as silos then again also opens up another hard problem, which is synchronisation.<br>As this is an overview document, I am not going to dive too deep into this problem set right now - for now, it is sufficient to point out that these issues exist and need to be dealt with.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on December 30, 2023</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://lucem.github.io/blockyvoxels/if-anyone-cares-how-this-blog-works.html" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  If anyone cares - how this blog works "><span class="btn__icon">←</span> <span class="btn__text">If anyone cares - how this blog works</span> </a><a href="https://lucem.github.io/blockyvoxels/what-the-game-might-be.html" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  What the Game might be "><span class="btn__text">What the Game might be</span> <span class="btn__icon">→</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>Published initially on December 30th, 2023<br>Copyleft - lucem<br>Powered by Publii CMS</p></div></div></footer></div><script defer="defer" src="https://lucem.github.io/blockyvoxels/assets/js/scripts.min.js?v=74fad06980c30243d91d72c7c57fcdb8"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>